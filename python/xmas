#!/usr/bin/env ipython3
import time
import random
import opc
import colorsys
import color_utils
import math

ADDRESS = 'localhost:7890'



class Strand:
	def __init__(self, size, brightness=1):
		self._pixels = [(0,0,0)] * size
		self._client = opc.Client(ADDRESS)
		self.brightness = brightness


	def __len__(self):
		return len(self._pixels)

	def __getitem__(self, idx):
		return self._pixels[idx]

	def __setitem__(self, idx, value):
		self._pixels[idx] = value

	def push(self):
		intPixels = [ (int(p[1]*255*self.brightness), int(p[0]*255*self.brightness), int(p[2]*255*self.brightness)) for p in self._pixels]
		self._client.put_pixels(intPixels, channel=0)

	def clear(self):
		for i in range(len(self)):
			self[i] = (0,0,0)


def scaleColor(scale, color):
	return tuple(scale*comp for comp in color)


def mapsin(x, minx, maxx, ncycles):
	x -= minx
	x /= (maxx - minx)
	x *= 2*math.pi * ncycles
	x -= math.pi/2
	x = math.sin(x)
	x += 1
	x /= 2
	return x




class Pattern:
	def __init__(self, strand):
		self._time = 0
		self._strand = strand
		self._delta = 0

	def _update(self):
		assert False

	def process(self, delta):
		self._delta = delta
		self._time += delta
		self._update()
		self._strand.push()



class FadeIn(Pattern):
	def __init__(self, strand, period):
		super().__init__(strand)
		self._period = period
		self._curColor = (1,0,0)

	def _update(self):
		if self._time > self._period:
			self._time -= self._period
			self._curColor = colorsys.hsv_to_rgb(random.random(), 1, 1)

		for i in range(len(self._strand)):
			strand[i] = tuple(comp * (self._time/self._period) for comp in self._curColor)


			
class FadeOut(Pattern):
	def __init__(self, strand, period):
		super().__init__(strand)
		self._period = period
		self._curColor = (1,0,0)

	def _update(self):
		if self._time > self._period:
			self._time -= self._period
			self._curColor = colorsys.hsv_to_rgb(random.random(), 1, 1)

		for i in range(len(self._strand)):
			strand[i] = tuple(comp * (1-self._time/self._period) for comp in self._curColor)


class FadeInOut(Pattern):
	def __init__(self, strand, period):
		super().__init__(strand)
		self._period = period
		self._curColor = (1,0,0)

	def _update(self):
		if self._time > self._period:
			self._time -= self._period
			self._curColor = colorsys.hsv_to_rgb(random.random(), 1, 1)


		scale = None
		if self._time < (self._period/2):
			scale = self._time/(self._period/2)
		else:
			scale = color_utils.remap(self._time, self._period/2, self._period, 1, 0)

		for i in range(len(self._strand)):
			strand[i] = tuple(comp * (scale) for comp in self._curColor)



class MovingRainbow(Pattern):
	def __init__(self, strand, period, ncycles):
		super().__init__(strand)
		self._period = period
		self._ncycles = ncycles

	def _update(self):
		offset = self._time/self._period
		for i in range(len(self._strand)):
			strand[i] = colorsys.hsv_to_rgb((offset + (i*self._ncycles)/len(self._strand)) % 1, 1, 1)



			
# class Trail(Pattern):
# 	def __init__(self, nheads, strand, moveperiod, colorperiod, initdecay, decay):
# 		super().__init__(strand)
# 		self._nheads = nheads
# 		self._moveperiod = moveperiod
# 		self._colorperiod = colorperiod
# 		self._decay = decay
# 		self._initdecay = initdecay
# 		self._prevhead = 0	
	


# 	def _update(self):
# 		basehead = int(len(self._strand) * self._time/self._moveperiod) % len(self._strand)
# 		heads = []
# 		for n in range(self._nheads):
# 			heads.append(basehead + len(self._strand) // self._nheads
# 		# head = int(len(self._strand) * self._time/self._moveperiod) % len(self._strand)

# 		curColor = colorsys.hsv_to_rgb((self._time / self._colorperiod) % 1, 1, 1)

# 		for i in range(len(self._strand)):
# 			if i == head:
# 				strand[i] = (1,1,1)
# 			elif i == self._prevhead: # just changed since prevhead != head
# 				strand[i] = scaleColor(self._initdecay, curColor)
# 			else:
# 				strand[i] = scaleColor(self._decay, strand[i])



# 		self._prevhead = head


class Trail(Pattern):
	def __init__(self, strand, nheads, moveperiod, colorperiod, initdecay, decay):
		super().__init__(strand)
		self._nheads = nheads
		self._moveperiod = moveperiod
		self._colorperiod = colorperiod
		self._decay = decay
		self._initdecay = initdecay
		self._prevheads = [0] * nheads	
	


	def _update(self):
		basehead = int(len(self._strand) * self._time/self._moveperiod) % len(self._strand)
		heads = []
		for n in range(self._nheads):
			heads.append( (basehead + n*len(self._strand) // self._nheads) % len(self._strand) )
		# head = int(len(self._strand) * self._time/self._moveperiod) % len(self._strand)

		# print(heads)



		curColor = colorsys.hsv_to_rgb((self._time / self._colorperiod) % 1, 1, 1)

		for i in range(len(self._strand)):
			if i in heads:
				strand[i] = (1,1,1)
			elif i in self._prevheads: # just changed since prevhead != head
				strand[i] = scaleColor(self._initdecay, curColor)
			else:
				strand[i] = scaleColor(self._decay, strand[i])



		self._prevheads = heads[:]




			
# class TheatreChase(Pattern):
# 	def __init__(self, strand, period, width):
# 		super().__init__(strand)
# 		self._period = period
# 		self._width = width

# 	def _update(self):
# 		offset = int(self._width*self._time/self._period) % self._width
# 		self._strand.clear()
# 		for i in range(offset, len(self._strand), self._width):
# 			strand[i] = (1,1,1)

	


			
class Flicker(Pattern):
	def __init__(self, strand, period, ontime):
		super().__init__(strand)
		self._period = period
		self._ontime = ontime
		self._phases = [random.random()*period for _ in range(len(strand))]

	def _update(self):
		for i in range(len(self._strand)):
			self._phases[i] += self._delta
			self._phases[i] %= self._period
			if self._phases[i] < self._ontime:
				self._strand[i] = scaleColor(mapsin(self._phases[i], 0, self._ontime, 5),(1,1,1))
			else:
				self._strand[i] = (0,0,0)

	



if __name__ == '__main__':
	strand = Strand(255, 0.3)

	# for i in range(len(strand)):
	# 	strand[i] = (1,0,0)

	# strand.push()


	targetFPS = 100
	targetDelta = 1/targetFPS


	patterns = [
		# FadeIn(strand, 2),
		# FadeOut(strand, 2)
		# FadeInOut(strand, 3)
		# MovingRainbow(strand, 10, len(strand)) # uniform rainbow,
		# MovingRainbow(strand, 10, 1) 
		# Trail(strand, 2, 9, 3, 1, 0.995)
		# TheatreChase(strand, 3, 4)
		Flicker(strand, 5, 1)
		
	]

	timePerPattern = 100000

	# fadeIn = FadeOut(strand, 3)



	patternIdx = 0
	patternTimeRemaining = timePerPattern

	frameCnt = 0
	frameCntTimer = 0
	frameCntPeriod = 1

	prevTime = time.time()
	while True:
		delta = time.time() - prevTime
		prevTime += delta

		patterns[patternIdx].process(targetDelta)
		frameCnt += 1
		frameCntTimer += delta

		if frameCntTimer >= frameCntPeriod:
			print('FPS: {}'.format(frameCnt/ frameCntTimer))
			frameCnt = 0
			frameCntTimer = 0
			# print('detla,', delta)

		patternTimeRemaining -= delta
		if patternTimeRemaining <= 0:
			strand.clear()
			patternTimeRemaining += timePerPattern
			patternIdx = (patternIdx+1) % len(patterns)


		nextFrameAt = prevTime + 0.01
		sleepTime =  nextFrameAt - time.time()
		if sleepTime > 0:
			time.sleep(sleepTime)




	

	